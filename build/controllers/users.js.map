{"version":3,"sources":["../../src/controllers/users.js"],"names":["keys","process","env","AuthenticationController","req","res","body","errors","isValid","status","json","User","findOne","username","then","user","email","newUser","password","bcrypt","genSalt","err","salt","hash","save","msg","console","log","compare","isMatch","payload","id","name","avatar","jwt","sign","JWT_SECRET","expiresIn","token","success"],"mappings":"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","sourcesContent":["import jwt from 'jsonwebtoken';\r\nimport bcrypt from 'bcryptjs';\r\nconst keys = process.env;\r\nimport validateRegisterInput from '../validation/users/registration';\r\nimport validateLoginInput from '../validation/users/login';\r\nimport User from '../models/User';\r\n\r\n\r\nclass AuthenticationController{\r\n    static async register(req, res){\r\n        const { errors, isValid } = validateRegisterInput(req.body);\r\n\r\n        if (!isValid) {\r\n            return res.status(400).json(errors);\r\n        }\r\n\r\n        User.findOne({ username: req.body.username }).then(user => {\r\n            if (user) {\r\n                return res.status(400).json({ username: [\"Username already exists\"] });\r\n            }\r\n        });\r\n        User.findOne({ email: req.body.email }).then(user => {\r\n            if (user) {\r\n                return res.status(400).json({ email: [\"Email already exists\"] });\r\n            } else {\r\n                const newUser = new User({\r\n                    username: req.body.username,\r\n                    email: req.body.email,\r\n                    password: req.body.password\r\n                });\r\n                bcrypt.genSalt(8, (err, salt) => {\r\n                    bcrypt.hash(newUser.password, salt, (err, hash) => {\r\n                        if (err) throw err;\r\n                        newUser.password = hash;\r\n                        newUser\r\n                            .save()\r\n                            .then(user => res.status(201).json({user, msg:'You have succesfully registered a user'}))\r\n                            .catch(err => console.log(err));\r\n                    });\r\n                });\r\n            }\r\n        });\r\n\r\n    }\r\n    static async login(req, res){\r\n        const { errors, isValid } = validateLoginInput(req.body);\r\n\r\n        // Check Validation\r\n        if (!isValid) {\r\n            return res.status(400).json(errors);\r\n        }\r\n\r\n        const email = req.body.email;\r\n        const password = req.body.password;\r\n\r\n        // Find user by email\r\n        await User.findOne({ email }).then(user => {\r\n            // Check for user\r\n            if (!user) {\r\n                errors.email = 'User not found';\r\n                return res.status(404).json(errors);\r\n            }\r\n\r\n            // Check Password\r\n            bcrypt.compare(password, user.password).then(isMatch => {\r\n                if (isMatch) {\r\n                    // User Matched\r\n                    const payload = { id: user.id, name: user.name, avatar: user.avatar }; // Create JWT Payload\r\n\r\n                    // Sign Token\r\n                    jwt.sign(\r\n                        payload,\r\n                        keys.JWT_SECRET,\r\n                        { expiresIn: 3600 },\r\n                        (err, token) => {\r\n                            res.json({\r\n                                success: true,\r\n                                token: 'Bearer ' + token\r\n                            });\r\n                        }\r\n                    );\r\n                } else {\r\n                    errors.password = 'Incorrect Password';\r\n                    return res.status(400).json(errors);\r\n                }\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    static async getCurrentUser(req, res) {\r\n        res.json({\r\n            id: req.user.id,\r\n            username: req.user.username,\r\n            email: req.user.email,\r\n            msg: \"success\"\r\n        });\r\n\r\n    }\r\n}\r\n\r\nexport default AuthenticationController"],"file":"users.js"}